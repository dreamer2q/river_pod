---
title: 使用一个 Provider
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import CodeBlock from "@theme/CodeBlock";
import counter from "!!raw-loader!/docs/concepts/reading_counter.dart";
import consumerWidget from "!!raw-loader!/docs/concepts/reading_consumer_widget.dart";
import consumerStatefulWidget from "!!raw-loader!/docs/concepts/reading_consumer_stateful_widget.dart";
import consumerHookWidget from "!!raw-loader!/docs/concepts/reading_consumer_hook_widget.dart";
import statefulHookConsumerWidget from "!!raw-loader!/docs/concepts/reading_stateful_hook_consumer_widget.dart";
import consumerHook from "!!raw-loader!/docs/concepts/reading_consumer_hook.dart";
import watch from "!!raw-loader!/docs/concepts/reading_watch.dart";
import watchBuild from "!!raw-loader!/docs/concepts/reading_watch_build.dart";
import listen from "!!raw-loader!/docs/concepts/reading_listen.dart";
import listenBuild from "!!raw-loader!/docs/concepts/reading_listen_build.dart";
import read from "!!raw-loader!/docs/concepts/reading_read.dart";
import readBuild from "!!raw-loader!/docs/concepts/reading_read_build.dart";
import readNotifierBuild from "!!raw-loader!/docs/concepts/reading_read_notifier_build.dart";
import watchNotifierBuild from "!!raw-loader!/docs/concepts/reading_watch_notifier_build.dart";
import { trimSnippet } from "../../../../../src/components/CodeSnippet";

在阅读这个指南前，请先阅读[关于 Provider](/docs/concepts/providers)。

在这个指南中，我们将看到如何使用一个 provider。

## 获取一个 “ref” 对象

首先，在使用 provider 之前，我们需要获取一个 “ref” 对象。

这个对象可以让我们与其它 provider 进行交互，可以从一个 widget 或者另一个 provider 获得。

### 从 provider 获取 “ref”

所有 provider 接收一个 “ref” 作为参数：

```dart
final provider = Provider((ref) {
  // 使用 ref 获取其他 provider
  final repository = ref.watch(repositoryProvider);

  return SomeValue(repository);
})
```

这个参数可以安全地用来传递由 provider 暴露的值。

例如，一个常见的使用场景是将 provider 的 “ref” 传递给 [StateNotifier]：

<CodeBlock>{trimSnippet(counter)}</CodeBlock>

这样做允许我们的 `Counter` 类读取 providers。

### 从 widget 获取 “ref”

组件自然不会有 ref 参数。但是 [Riverpod] 提供了多种方法从 widget 获取一个 ref。

#### 使用 ConsumerWidget 替代 StatelessWidget

通过 widget 获取 ref 对象最常见的方式是使用 [ConsumerWidget] 替换 [StatelessWidget]。

[ConsumerWidget] 和 [StatelessWidget] 相同，只是它们的 build 方法有一个额外的参数：“ref” 对象。

一个典型的 [ConsumerWidget] 像这样：

<CodeBlock>{trimSnippet(consumerWidget)}</CodeBlock>

#### 使用 ConsumerStatefulWidget+ConsumerState 替代 StatefulWidget+State

与 [ConsumerWidget] 情况相似，[ConsumerStatefulWidget] 和 [ConsumerState] 相同，
只是它们的 state 有一个额外的参数：“ref” 对象。

这次，“ref” 不会传递给 build 方法，但是它是 [ConsumerState] 的一个属性：

<CodeBlock>{trimSnippet(consumerStatefulWidget)}</CodeBlock>

#### 使用 HookConsumerWidget 替代 HookWidget

这个选项是给 [flutter_hooks] 用户的。因为 [flutter_hooks] 需要扩展 [HookWidget] 来工作，

这个包 [hooks_riverpod] 公开了一个新的 widget 名为 [HookConsumerWidget]。
[HookConsumerWidget] 具有 [ConsumerWidget] 和 [HookWidget] 的行为。
这使得一个 widget 可以同时监听 providers 和使用 hooks。

一个例子如下：

<CodeBlock>{trimSnippet(consumerHookWidget)}</CodeBlock>

#### 使用 StatefulHookConsumerWidget 替代 HookWidget

这个选项是给 [flutter_hooks] 用户，需要使用 hooks 和 [StatefulWidget] 的生命周期方法。

一个例子如下：

<CodeBlock>{trimSnippet(statefulHookConsumerWidget)}</CodeBlock>

#### Consumer 和 HookConsumer 组件

一个最终的方式在 widgets 中获取 “ref” 是通过依赖 [Consumer]/
[HookConsumer]。

这些类可以在 builder 回调中获取 “ref”，具有和 [ConsumerWidget]/[HookConsumerWidget] 相同的属性。

例如，这些 widgets 是一种获取 “ref” 方式，不需要定义类。
一个例子如下：

<CodeBlock>{trimSnippet(consumerHook)}</CodeBlock>

## 使用 ref 与 providers 交互

现在我们有了 “ref”，我们可以开始使用它。

There are three primary usages for "ref":

“ref” 有三个主要用途的：

- obtaining the value of a provider and listening to changes, such that when
  this value changes, this will rebuild the widget or provider that subscribed
  to the value.
  This is done using `ref.watch`

- 获取 provider 的值，并监听变化，这样当这个值变化时，这将重建订阅这个值的 widget 或 provider。
  这是通过 `ref.watch` 完成的

- 添加 provider 的监听器，以执行一些操作，例如导航到新的页面或显示一个模态框，
  这是通过 `ref.listen` 完成的

- obtaining the value of a provider while ignoring changes.
  This is useful when we need the value of a provider in an event
  such as "on click".
  This is done using `ref.read`.

- 获取 provider 的值，忽略变化。
  这是在事件中 (例如 click 事件) 需要 provider 的值时使用的。
  这是通过 `ref.read` 完成的

:::note

只要可能，建议使用 `ref.watch` 代替 `ref.read` 或 `ref.listen` 来实现一个功能。

通过依赖 `ref.watch`，你的应用程序变成了响应式和生命式的，这使得它更容易维护。  
:::

### 使用 ref.watch 监听 provider

`ref.watch` 在 widget 的 `build` 方法中使用，或者在 provider 的创建函数中使用，
以便 widget/provider 监听其它 provider 的变化。

例如，provider 可以使用 `ref.watch` 来将多个 provider 组合成一个新的值。

一个例子如下：过滤一个 todo-list。
我们可以有两个 providers：

- `filterTypeProvider`，一个 provider，暴露当前类型的过滤器（none，显示 only completed tasks，...）

- `todosProvider`，一个 provider，暴露整个任务列表

通过使用 `ref.watch`，我们可以使用第三个 provider，将两个 providers 组合成一个过滤的任务列表。

<CodeBlock>{trimSnippet(watch)}</CodeBlock>

使用这段代码，`filteredTodoListProvider` 将暴露过滤的任务列表。

这个列表将自动更新，如果过滤器或任务列表改变。
同时，过滤的列表不会被重新计算，如果过滤器或任务列表没有改变。

类似地，widget 可以使用 `ref.watch` 来显示 provider 的内容，并在内容改变时更新用户界面。

<CodeBlock>{trimSnippet(watchBuild)}</CodeBlock>

这段代码展示了一个侦听 provider，该 provider 存储一个 `count`，
如果 `count` 改变，widget 将重新构建并显示新的值。

:::caution
这个 `watch` 方法不可以被异步调用，例如不应该在 [ElevatedButton] 的 `onPressed` 中调用，
也不应该在 `initState` 和其他 [State] 生命周期中使用。

在这些情况下，建议使用 `ref.read` 代替。
:::

### 使用 ref.listen 响应 provider 变化

和 `ref.watch` 相同，可以使用 `ref.listen` 观察 provider。

这两种方法的主要区别在于，如果侦听的 provider 改变，使用 `ref.listen` 将调用一个自定义函数，
而不是重新构建 widget/provider。

这可以用来执行某些变化时的操作，例如当发生错误时显示 snackbar。

这 `ref.listen` 方法需要 2 个位置参数，第一个是 Provider，第二个是我们想要执行的回调函数。
回调函数调用时会传入 2 个值，前一个 State 的值和新的 State 的值。

这 `ref.listen` 方法可以在 provider 的构造方法中使用：

<CodeBlock>{trimSnippet(listen)}</CodeBlock>

或者在 widget 的 `build` 方法中使用：

<CodeBlock>{trimSnippet(listenBuild)}</CodeBlock>

:::caution
这 `listen` 方法不可以被异步调用，例如不应该在 [ElevatedButton] 的 `onPressed` 中调用，
也不应该在 `initState` 和其他 [State] 生命周期中使用。
:::

### 使用 ref.read 获取 provider 的状态

这个 `ref.read` 方法是获取 provider 的状态的一种方法，而不是侦听它。

这个方法通常在用户交互触发的函数中使用。
例如，我们可以使用 `ref.read` 来在用户点击按钮时增加一个计数器：

<CodeBlock>{trimSnippet(read)}</CodeBlock>

:::note
使用 `ref.read` 应该尽量避免，因为它不是响应式的。

它存在于使用 `watch` 或 `listen` 可能会导致问题的情况下。
如果可以，最好使用 `watch`/`listen`，尤其是 `watch`。
:::

#### **不要**在 build 方法中使用 `ref.read`

你可能会被吸引到使用 `ref.read` 来优化一个 widget 的性能:

<CodeBlock>{trimSnippet(readBuild)}</CodeBlock>

但这是一个非常坏的做法，它可能会导致难以跟踪的 bug。

Using `ref.read` this way is commonly associated with the thought "The value
exposed by a provider never changes so using 'ref.read' is safe". The problem
with this assumption is that, while today that provider may indeed never update
its value, there is no guarantee that tomorrow will be the same.

使用 `ref.read` 这种方法通常会认为 “provider 的值永远不会改变，所以使用 `ref.read` 是安全的”。
这个假设的问题是，你永远无法保障 provider 不会随着时间而改变，即使今天它不会改变，
但是你无法保证它明天也不会变化。

Software tends to change a lot, and it is likely that in the future, a value
that previously never changed will need to change.  
If you use `ref.read`, when that value needs to change, you have
to go through your entire codebase to change `ref.read` into `ref.watch` –
which is error prone and you are likely to forget some cases.

软件是趋于变化的，而且以后，一个从未改变过的值可能需要改变。
如果你使用 `ref.read`，当那个值需要改变时，你需要在整个代码库中更改 `ref.read` 为 `ref.watch`，
这是容易出错的，你可能会遗漏某些情况。

如果你一开始就使用 `ref.watch`，当你重构时，你将会遇到更少问题。

**_ 但我就是想用 `ref.read` 来减少我的 widget 重建的次数啊。_**

即使目标是很棒的，但是要注意，你可以使用 `ref.watch` 来实现相同的效果（减少重建次数）。

Providers offer various ways to obtain a value while reducing the number of
rebuilds, which you could use instead.

Providers 提供了多种方式来获取值，同时也减少重建次数，你可以使用它来代替。

例如，不要使用下面方式：

<CodeBlock>{trimSnippet(readNotifierBuild)}</CodeBlock>

我们可以这样做：

<CodeBlock>{trimSnippet(watchNotifierBuild)}</CodeBlock>

两个代码块都实现了相同的效果：我们的按钮不会重建，当计数器增加。

On the other hand, the second approach supports cases where the counter is reset.
For example, another part of the application could call:

另一方面，第二种方法支持计数器重置的情况。例如，应用程序的其它部分可以调用：

```dart
ref.refresh(counterProvider);
```

这样就可以重新创建 `StateController` 对象。

如果这里我们使用 `ref.read`，我们的按钮依旧使用了前一个 `StateController` 实例，
它已经被释放了，应该不再使用。而使用 `ref.watch` 就可以正确地重建按钮来使用新的 `StateController`。

## 决定要监听什么

取决于你想监听的 provider，你可能有多个可能的值，你可以监听。

作为一个例子，考虑下面的 [StreamProvider]：

```dart
final userProvider = StreamProvider<User>(...);
```

当你读取这个 `userProvider` 时，你可以：

- 同步读取当前状态，通过监听 `userProvider` 本身：

  ```dart
  Widget build(BuildContext context, WidgetRef ref) {
    AsyncValue<User> user = ref.watch(userProvider);

    return user.when(
      loading: () => const CircularProgressIndicator(),
      error: (error, stack) => const Text('Oops'),
      data: (user) => Text(user.name),
    );
  }
  ```

- 获取相关联的 [Stream]，通过监听 `userProvider.stream`：

  ```dart
  Widget build(BuildContext context, WidgetRef ref) {
    Stream<User> user = ref.watch(userProvider.stream);
  }
  ```

- 获取一个 [Future]，它会解析最新的值，通过监听 `userProvider.future`：

  ```dart
  Widget build(BuildContext context, WidgetRef ref) {
    Future<User> user = ref.watch(userProvider.future);
  }
  ```

其它的 provider 可能提供不同的可选值。

更多信息，请参考每个 provider 的文档，
参考 [API reference](https://pub.dev/documentation/riverpod/latest/riverpod/riverpod-library.html)。

## 使用 "select" 来过滤重建

最后一个特性与读取 providers 相关，可以减少从 `ref.watch` 重建次数，或者 `ref.listen` 执行一个函数的次数。

这是重要的，因为，默认情况下，监听 provider 时会监听整个对象的状态。
但是，有时，widget/provider 可能只关心某些属性的变化，而不是整个对象。

例如，一个 provider 可能暴露一个 `User`：

```dart
abstract class User {
  String get name;
  int get age;
}
```

但是，一个 widget 只需要使用 `User` 的 name 属性：

```dart
Widget build(BuildContext context, WidgetRef ref) {
  User user = ref.watch(userProvider);
  return Text(user.name);
}
```

If we naively used `ref.watch`, this would rebuild the widget when the user's
`age` changes.

如果我们使用 `ref.watch`，这样就会重建 widget 当 user 的 `age` 变化。

解决方案是使用 `select` 来明确告诉 [Riverpod] 只监听 `User` 的 name 属性的变化。

更新后的代码是：

```dart
Widget build(BuildContext context, WidgetRef ref) {
  String name = ref.watch(userProvider.select((user) => user.name));
  return Text(name);
}
```

通过 `select`，我们可以指定一个返回我们关心的属性的函数。

无论何时 user 变化了，Riverpod 会调用这个函数，并且比较之前和新的结果。
如果他们不同（例如，当 name 变化了），Riverpod 会重建 widget。

然而，如果他们相等（例如，当 age 变化了），Riverpod 不会重建 widget。

:::info
也可以使用 `select` 与 `ref.listen`：

```dart
ref.listen<String>(
  userProvider.select((user) => user.name),
  (String? previousName, String newName) {
    print('The user name changed $newName');
  }
);
```

这样做，只有当 name 变化了就会调用监听回调函数。
:::

:::tip
You don't have to return a property of the object. Any value that
overrides == will work. For example you could do:

你不必返回对象某个属性。任何值，只要它重写了 == 操作符将可以工作。例如，你可以做：

```dart
final label = ref.watch(userProvider.select((user) => 'Mr ${user.name}'));
```

:::

[stateprovider]: ../providers/state_provider
[providercontainer]: https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html
[providerlistener]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderListener-class.html
[providerscope]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html
[consumer]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/Consumer-class.html
[consumerwidget]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ConsumerWidget-class.html
[consumerstate]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ConsumerStatefulWidget-class.html
[consumerstatefulwidget]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ConsumerState-class.html
[useprovider]: https://pub.dev/documentation/hooks_riverpod/latest/hooks_riverpod/ref.watch(.html
[elevatedbutton]: https://api.flutter.dev/flutter/material/ElevatedButton-class.html
[streambuilder]: https://api.flutter.dev/flutter/widgets/StreamBuilder-class.html
[riverpod]: https://github.com/rrousselgit/river_pod
[text]: https://api.flutter.dev/flutter/widgets/Text-class.html
[hooks_riverpod]: https://pub.dev/packages/hooks_riverpod
[future]: https://api.dart.dev/stable/2.13.4/dart-async/Future-class.html
[stream]: https://api.dart.dev/stable/2.13.4/dart-async/Stream-class.html
[hookwidget]: https://pub.dev/documentation/flutter_hooks/latest/flutter_hooks/HookWidget-class.html
[hookconsumerwidget]: https://pub.dev/documentation/hooks_riverpod/latest/hooks_riverpod/HookConsumerWidget-class.html
[hookconsumer]: https://pub.dev/documentation/hooks_riverpod/latest/hooks_riverpod/HookConsumer-class.html
[flutter_riverpod]: https://pub.dev/packages/flutter_riverpod
[flutter_hooks]: https://github.com/rrousselGit/flutter_hooks
[statenotifier]: https://pub.dev/documentation/state_notifier/latest/state_notifier/StateNotifier-class.html
[streamprovider]: ../providers/stream_provider
[statelesswidget]: https://api.flutter.dev/flutter/widgets/StatelessWidget-class.html
[statefulwidget]: https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html
[state]: https://api.flutter.dev/flutter/widgets/State-class.html
